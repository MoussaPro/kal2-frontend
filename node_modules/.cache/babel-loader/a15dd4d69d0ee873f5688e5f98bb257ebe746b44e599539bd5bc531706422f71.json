{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar VueRouteMiddleware = function () {\n  /**\r\n   * Set instance properties and call defined \r\n   * middlewares on matching routes\r\n   * \r\n   * @param {object} definedMiddlewares \r\n   * @param {object} to \r\n   * @param {object} from \r\n   * @param {function|undefined} next\r\n   * \r\n   * @var {object} middlewares // predefined middlewares\r\n   * @var {boolean} nextHasCalled // if next was called in the middlewares\r\n   * @var {array} toMiddleware // arguments passed to middleware function\r\n   */\n  function VueRouteMiddleware(definedMiddlewares, to, from, next) {\n    var _this = this;\n    _classCallCheck(this, VueRouteMiddleware);\n    if (this._isObject(definedMiddlewares)) {\n      this.middlewares = definedMiddlewares;\n    } else {\n      this._error('Defined middlewares must be of type Object!');\n      this.middlewares = {};\n    }\n    this.to = to;\n    this.from = from;\n    this.next = next;\n    this.nextHasCalled = false;\n    if (this.to && this.to.matched) {\n      // Apply middleware if anu route matched\n      to.matched.every(function (route) {\n        return _this.applyRouteMiddlewares(route);\n      });\n    }\n    if (this.next && !this.nextHasCalled) {\n      // call next if user didnt call it\n      this.callNext();\n    }\n  }\n\n  /**\r\n   * Function used to pass arguments to middlewares with spred syntax\r\n   * \r\n   * @return {array}\r\n   */\n\n  _createClass(VueRouteMiddleware, [{\n    key: 'toMiddleware',\n    value: function toMiddleware() {\n      return [this.to, this.from, this._isFunction(this.next) ? this.callNext.bind(this) : undefined];\n    }\n\n    /**\r\n     * Function that is passed to middleware as a next function wrapper\r\n     * toggling `nextHasCalled` trigger\r\n     * \r\n     * @param  {...any} args\r\n     */\n  }, {\n    key: 'callNext',\n    value: function callNext() {\n      if (!this.nextHasCalled) this.nextHasCalled = true;\n      return this.next.apply(this, arguments);\n    }\n  }, {\n    key: 'applyRouteMiddlewares',\n    /**\r\n     * Fuction applying middlewares of a single route and deciding\r\n     * if other matched routes should be checked as well\r\n     * \r\n     * @param {*} route \r\n     * \r\n     * @return {boolean}\r\n     */\n    value: function applyRouteMiddlewares(route) {\n      var _this2 = this;\n      if (route.meta && route.meta.middleware) {\n        var middlewareKeys = route.meta.middleware;\n        if (this._isArray(middlewareKeys)) {\n          return middlewareKeys.every(function (middleware) {\n            return _this2.applyMiddleware(middleware);\n          });\n        } else {\n          return this.applyMiddleware(middlewareKeys);\n        }\n      }\n      return true;\n    }\n\n    /**\r\n     * Function calling middlewares and deciding if middleware chain\r\n     * must be continued or stopped after first faliure\r\n     * \r\n     * @param {string|function} middleware \r\n     * \r\n     * @return {boolean}\r\n     */\n  }, {\n    key: 'applyMiddleware',\n    value: function applyMiddleware(middleware) {\n      var result = this.getMiddleware(middleware).apply(undefined, _toConsumableArray(this.toMiddleware()));\n      return result === undefined ? true : result;\n    }\n\n    /**\r\n     * Function to get middleware function.\r\n     * In case of function validation failure\r\n     * console the error and return empty function\r\n     * \r\n     * @param {string|function} middleware \r\n     * \r\n     * @return {function}\r\n     */\n  }, {\n    key: 'getMiddleware',\n    value: function getMiddleware(middleware) {\n      if (this._isString(middleware)) {\n        if (this.middlewares.hasOwnProperty(middleware)) {\n          if (this._isFunction(this.middlewares[middleware])) {\n            return this.middlewares[middleware];\n          } else {\n            this._error(middleware + ' is not a function!');\n          }\n        }\n      } else if (this._isFunction(middleware)) {\n        return middleware;\n      } else {\n        this._error('All middlewares must be functions!');\n      }\n      return function () {\n        return true;\n      };\n    }\n\n    /**\r\n     * @param {string} text \r\n     * \r\n     * @return {boolean}\r\n     */\n  }, {\n    key: '_error',\n    value: function _error(text) {\n      console.error(this.constructor.name + ': ' + text);\n    }\n\n    /**\r\n     * @param {*} toCheck \r\n     * \r\n     * @return {boolean}\r\n     */\n  }, {\n    key: '_isString',\n    value: function _isString(toCheck) {\n      return typeof toCheck === \"string\" || toCheck instanceof String;\n    }\n\n    /**\r\n     * @param {*} toCheck \r\n     * \r\n     * @return {boolean}\r\n     */\n  }, {\n    key: '_isArray',\n    value: function _isArray(toCheck) {\n      return Array.isArray(toCheck);\n    }\n\n    /**\r\n     * @param {*} toCheck \r\n     * \r\n     * @return {boolean}\r\n     */\n  }, {\n    key: '_isFunction',\n    value: function _isFunction(toCheck) {\n      return typeof toCheck === \"function\";\n    }\n\n    /**\r\n     * @param {*} toCheck \r\n     * \r\n     * @return {boolean}\r\n     */\n  }, {\n    key: '_isObject',\n    value: function _isObject(toCheck) {\n      return (typeof toCheck === 'undefined' ? 'undefined' : _typeof(toCheck)) === \"object\" && toCheck !== null;\n    }\n  }]);\n  return VueRouteMiddleware;\n}();\n;\nexports.default = function () {\n  var definedGroups = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function () {\n    for (var _len = arguments.length, toMiddleware = Array(_len), _key = 0; _key < _len; _key++) {\n      toMiddleware[_key] = arguments[_key];\n    }\n    return new (Function.prototype.bind.apply(VueRouteMiddleware, [null].concat([definedGroups], toMiddleware)))();\n  };\n};","map":{"version":3,"mappings":"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","names":["VueRouteMiddleware","definedMiddlewares","to","from","next","_classCallCheck","_isObject","middlewares","_error","nextHasCalled","matched","every","_this","applyRouteMiddlewares","route","callNext","_isFunction","bind","undefined","meta","middleware","middlewareKeys","_isArray","_this2","applyMiddleware","result","getMiddleware","toMiddleware","_isString","hasOwnProperty","text","console","error","constructor","name","toCheck","String","Array","isArray","definedGroups"],"sources":["../src/index.js"],"sourcesContent":["class VueRouteMiddleware {\r\n\r\n    /**\r\n     * Set instance properties and call defined \r\n     * middlewares on matching routes\r\n     * \r\n     * @param {object} definedMiddlewares \r\n     * @param {object} to \r\n     * @param {object} from \r\n     * @param {function|undefined} next\r\n     * \r\n     * @var {object} middlewares // predefined middlewares\r\n     * @var {boolean} nextHasCalled // if next was called in the middlewares\r\n     * @var {array} toMiddleware // arguments passed to middleware function\r\n     */\r\n    constructor(definedMiddlewares, to, from, next){\r\n        if(this._isObject(definedMiddlewares)){\r\n            this.middlewares = definedMiddlewares;\r\n        } else {\r\n            this._error('Defined middlewares must be of type Object!');\r\n            this.middlewares = {};\r\n        }\r\n        this.to = to;\r\n        this.from = from;\r\n        this.next = next;\r\n        this.nextHasCalled = false;\r\n        if(this.to && this.to.matched){ // Apply middleware if anu route matched\r\n            to.matched.every(route => this.applyRouteMiddlewares(route));\r\n        }\r\n        if(this.next && !this.nextHasCalled){ // call next if user didnt call it\r\n            this.callNext();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function used to pass arguments to middlewares with spred syntax\r\n     * \r\n     * @return {array}\r\n     */\r\n    toMiddleware(){\r\n        return [ \r\n            this.to, \r\n            this.from, \r\n            this._isFunction(this.next) ? \r\n                this.callNext.bind(this) : undefined\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Function that is passed to middleware as a next function wrapper\r\n     * toggling `nextHasCalled` trigger\r\n     * \r\n     * @param  {...any} args\r\n     */\r\n    callNext(...args){\r\n        if(!this.nextHasCalled) this.nextHasCalled = true;\r\n        return this.next(...args);\r\n    };\r\n\r\n    /**\r\n     * Fuction applying middlewares of a single route and deciding\r\n     * if other matched routes should be checked as well\r\n     * \r\n     * @param {*} route \r\n     * \r\n     * @return {boolean}\r\n     */\r\n    applyRouteMiddlewares(route){\r\n        if(route.meta && route.meta.middleware){\r\n            let middlewareKeys = route.meta.middleware;\r\n            if(this._isArray(middlewareKeys)){\r\n                return middlewareKeys.every(middleware => this.applyMiddleware(middleware));\r\n            } else {\r\n                return this.applyMiddleware(middlewareKeys);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Function calling middlewares and deciding if middleware chain\r\n     * must be continued or stopped after first faliure\r\n     * \r\n     * @param {string|function} middleware \r\n     * \r\n     * @return {boolean}\r\n     */\r\n    applyMiddleware(middleware){\r\n        const result = this.getMiddleware(middleware)(...this.toMiddleware());\r\n        return result === undefined ? true : result;\r\n    }\r\n\r\n    /**\r\n     * Function to get middleware function.\r\n     * In case of function validation failure\r\n     * console the error and return empty function\r\n     * \r\n     * @param {string|function} middleware \r\n     * \r\n     * @return {function}\r\n     */\r\n    getMiddleware(middleware){\r\n        if(this._isString(middleware)){\r\n            if(this.middlewares.hasOwnProperty(middleware)){\r\n                if(this._isFunction(this.middlewares[middleware])){\r\n                    return this.middlewares[middleware];\r\n                } else {\r\n                    this._error(middleware+' is not a function!');\r\n                }\r\n            }\r\n        } else if(this._isFunction(middleware)) {\r\n            return middleware;\r\n        } else {\r\n            this._error('All middlewares must be functions!');\r\n        }\r\n        return () => true;\r\n    }\r\n\r\n    /**\r\n     * @param {string} text \r\n     * \r\n     * @return {boolean}\r\n     */\r\n    _error(text){\r\n        console.error(this.constructor.name + ': '+text);\r\n    }\r\n\r\n    /**\r\n     * @param {*} toCheck \r\n     * \r\n     * @return {boolean}\r\n     */\r\n    _isString(toCheck){\r\n        return typeof toCheck === \"string\" || toCheck instanceof String;\r\n    }\r\n\r\n    /**\r\n     * @param {*} toCheck \r\n     * \r\n     * @return {boolean}\r\n     */\r\n    _isArray(toCheck){\r\n        return Array.isArray(toCheck);\r\n    }\r\n\r\n    /**\r\n     * @param {*} toCheck \r\n     * \r\n     * @return {boolean}\r\n     */\r\n    _isFunction(toCheck){\r\n        return typeof toCheck === \"function\";\r\n    }\r\n\r\n    /**\r\n     * @param {*} toCheck \r\n     * \r\n     * @return {boolean}\r\n     */\r\n    _isObject(toCheck){\r\n        return typeof toCheck === \"object\" && toCheck !== null;\r\n    }\r\n};\r\n\r\nexport default (definedGroups = {}) => {\r\n    return (...toMiddleware) => new VueRouteMiddleware(definedGroups, ...toMiddleware);\r\n};"]},"metadata":{},"sourceType":"script","externalDependencies":[]}